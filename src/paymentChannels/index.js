'use strict'

const fs = require('fs')

const EventEmitter = require('events');


const { bytesToHex } = require('web3').utils
const { recover } = require('secp256k1')

const { isPartyA, pubKeyToEthereumAddress, bufferToNumber, sendTransaction, log } = require('../utils')

const open = require('./open')
const close = require('./close')
const transfer = require('./transfer')
const settle = require('./settle')
const payout = require('./payout')

class PaymentChannel extends EventEmitter {
    constructor(node, contract, nonce) {
        super()

        this.openPaymentChannels = new Map()
        this.nonce = nonce
        this.contract = contract

        this.node = node
        this.open = open(this)
        this.close = close(this)
        this.transfer = transfer(this)
        this.settle = settle(this)
        this.payout = payout(this)
    }

    static createPaymentChannels(node, contract, cb) {
        node.web3.eth.getTransactionCount(pubKeyToEthereumAddress(node.peerInfo.id.pubKey.marshal()), (err, nonce) => {
            if (err) { throw err }

            node.paymentChannels = new PaymentChannel(node, contract, nonce)

            cb()
        })
    }

    setSettlementListener(channelId, listener = this.close) {
        let record
        if (this.has(channelId)) {
            record = this.openPaymentChannels.get(channelId.toString('base64'))
        } else {
            record = {}
        }

        record.listener = listener

        this.openPaymentChannels.set(channelId.toString('base64'), record)

        log(this.node.peerInfo.id, `Listening to channel \x1b[33m${channelId.toString('hex')}\x1b[0m`)
        this.contract.once('ClosedChannel', {
            topics: [bytesToHex(channelId)]
        }, record.listener)
    }

    getEmbeddedMoney(from, tx) {
        const self = pubKeyToEthereumAddress(this.node.peerInfo.id.pubKey.marshal())
        const otherParty = pubKeyToEthereumAddress(from.pubKey.marshal())

        const last = this.get(tx.channelId)

        if (isPartyA(self, otherParty)) {
            return tx.value - last.value
        } else {
            return last.value - tx.value
        }
    }

    getCounterParty(channelId) {
        if (!this.has(channelId))
            return null

        const restoreTx = this.getRestoreTransaction(channelId)

        return recover(restoreTx.hash, restoreTx.signature, bufferToNumber(restoreTx.recovery))
    }

    set(tx) {
        let record
        if (this.has(tx.channelId)) {
            record = this.openPaymentChannels.get(tx.channelId.toString('base64'))
        } else {
            record = {}
        }

        record.tx = tx

        this.openPaymentChannels.set(tx.channelId.toString('base64'), record)
    }

    setRestoreTransaction(restoreTx) {
        let record
        if (this.has(restoreTx.channelId)) {
            record = this.openPaymentChannels.get(restoreTx.channelId.toString('base64'))
        } else {
            record = {}
        }

        record.restoreTx = restoreTx

        this.openPaymentChannels.set(restoreTx.channelId.toString('base64'), record)
    }

    get(channelId) {
        if (!this.has(channelId))
            return null

        return this.openPaymentChannels.get(channelId.toString('base64')).tx
    }

    getRestoreTransaction(channelId) {
        if (!this.has(channelId))
            return null

        return this.openPaymentChannels.get(channelId.toString('base64')).restoreTx
    }

    has(channelId) {
        return this.openPaymentChannels.has(channelId.toString('base64'))
    }

    delete(channelId) {
        this.openPaymentChannels.delete(channelId.toString('base64'))
    }

    /**
     * Takes a transaction object generetad by web3.js and publishes it in the
     * network. It automatically determines the necessary amount of gas i
     * 
     * @param {Object} txObject the txObject generated by web3.js
     * @param {Object} paymentChannel a paymentChannel instance
     * @param {Object} web3 a web3.js instance
     * @param {Function} cb the function to be called afterwards
     */
    async contractCall(txObject, value, cb = () => { }) {
        if (typeof value === 'function') {
            cb = value
            value = '0'
        }

        const estimatedGas = await txObject.estimateGas({
            from: pubKeyToEthereumAddress(this.node.peerInfo.id.pubKey.marshal())
        })

        this.nonce = this.nonce + 1

        sendTransaction({
            to: this.contract._address,
            nonce: this.nonce - 1,
            gas: estimatedGas,
            data: txObject.encodeABI()
        }, this.node.peerInfo.id, this.node.web3, (err, receipt) => {
            if (err)
                throw err

            

            cb(null, receipt)
        })
    }

    import() {

    }

    export() {

    }
}

module.exports = PaymentChannel