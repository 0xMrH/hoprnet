\section{Definition and Notation}

HOPR uses elliptic-curve public-key cryptography to process packets and incentives. Operations are done using using the \href{https://en.bitcoin.it/wiki/Secp256k1}{secp256k1} curve, so on-chain and off-chain identities are identical.

If not otherwise stated, $\cdot$ means multiplication of a scalar with a point on the elliptic curve and $G$ refers to the standard base point stated on Bitcoin's \href{https://en.bitcoin.it/wiki/Secp256k1}{wiki page}.

Points on the curve are given by tuples $(x,y) \in \mathbb{F}_p \times \mathbb{F}_p$ over the finite field $\mathbb{F}_p$ where $p = 2^{255} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1$.

$ || $ means bit-wise concatenation, hence $\mathsf{0xaf} \ || \ \mathsf{0xfe}$ becomes $\mathsf{0xaffe}$.

$\oplus$ means bit-wise XOR, hence $a \oplus b = (a \land \lnot b) \lor (\lnot a \land b)$

If not otherwise stated, public keys are denoted capitalized and private keys use lower-case identifiers, both employing the ECDSA signature system, hence a public key $Y_i = y_i \cdot G$.

If not otherwise stated, strings are serialized using UTF-8 encoding.

\begin{comment}
\subsection{Implementation choices}

HOPR employs the following cryptographic primitives:

\begin{itemize}
    \item \textbf{Cyclic group} HOPR's Sphinx implementation uses an elliptic curve group on the secp256k1 curve. Operations are therefore performed on the elliptic curve.

    \item \textbf{Hash function} HOPR uses the BLAKE2s hash function, a cryptographic hash function faster than SHA-2 and SHA-3, yet at least as secure as SHA-3. It produces digests of 32 bytes.

    \item \textbf{MAC} HOPR uses HMAC based on the BLAKE2s hash function.

    \item \textbf{Encryption scheme} HOPR uses the LIONESS \cite{lionesspaper} implementation, using BLAKE2s as a hash function and ChaCha20 as a stream cipher.

    \item \textbf{Padding} The original Sphinx paper uses a sequence of 0s for padding. However, this allows the last mix node in the path to infer information about the length of the path and the final destination, hence breaking one of the security properties promised by Sphinx. In order to prevent this attack, HOPR replaces the 0-padding with randomized padding for the final mix node when $v<r$. This ensures the exit node cannot identify where the padding starts and thus will not be able to determine the path length. In the case where $v=r$ there is no need to add padding as the length of the path is the maximum length, and thus no additional information is being revealed.

\end{itemize}
\end{comment}
