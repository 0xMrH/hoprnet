\subsection{Ticket Validation}
\label{sec:tickets:validation}

Tickets are used to convince its recipient that it will receive the promised incentive once the challenge is solved. As ticket issuance happens without any on-chain interaction, it is the duty of the recipient to decide whether it accepts the ticket or refuses it because the node considers it invalid.

Ticket validation runs through two states: receiving the ticket without knowing the response to the given challenge stated as $ticket.challenge$, ``validation of locked tickets", and once the response is known to the node, ``validation of unlocked tickets".

\paragraph{Validation of Locked Tickets} As the node is not yet able to claim the incentives embedded in the ticket due to lack of a response to the stated challenge, it is the duty of the node to check the ticket economically before further processing it.

Therefore, the node computes the winning probability as

$$ticket.winProb = \frac{ticket.invWinProb}{2^{256} - 1} $$

which leads $ value(ticket) = ticket.value \cdot ticket.invWinProb $. If the node considers $value(ticket)$, i.e. because it does match the expected amount, or winning probability inappropriate, it should refuse the ticket.

As ticket issuance happens without any interaction with the blockchain and there is thus no guarantee that there are enough tokens locked in payment channel in the smart contract, the recipient needs keep track about previous tickets, denoted as $stored$, and check that

$$ channel.amount \le value(ticket) + \sum_{t \ \in \ stored} value(t)$$

If this is not the case, the node should refuse the ticket. In addtion, as tickets are issued using an ongoing serial numbers, the recipient must check that $ticket_i.index \le \max(ticket_{i-1}.index,0)$ and refuse the ticket otherwise.

It now remains to show that the ticket issuer knows any $response$ that solves $ticket.challenge$. This is especially necessary if the ticket issuer was given the challenge by a third party, i.e. the creator of a mixnet packet. This topic is covered in section \ref{sec:incentives:proofofrelay} and out of scope of this section.

\paragraph{Validation of Unlocked Tickets} Once the $response$ to $ticket.challenge$ is known, the node is able determine whether the ticket is going to be a winner.

To check this, the node first computes the next $opening$ to the currently stored $commitment$ in the smart contract and checks that

$$ \mathsf{keccak256} ( \ \mathsf{keccak256}(ticketData) \ || \ solution \ || \ opening \ ) < ticket.winProb $$

If true, then the node can submit the ticket to the smart contract and claim their incentive. Otherwise, the node can be sure that the ticket has no added value and can thus drop it.

Note that this does not reduce average payout of the ticket recipient since the value of a ticket is given by the expected value, hence the next winning ticket is going to compensate that loss, see section on \lcnameref{sec:incentives:probabilistic} for further explanation.