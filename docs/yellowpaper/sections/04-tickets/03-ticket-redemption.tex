\subsection{Ticket Redemption}
\label{sec:tickets:redemption}

After running through the validations as seen in the previous section, the node ends up with a set of stored tickets $stored$ which it considers to be a win.

As described, each ticket is given a \lcnameref{sec:tickets:issuance:ticketindex} working as a serial number to prevent from double-spend attempts and redeeming ticket with serial number $i$ invalidates all tickets with serial number $i' \le i$. Hence, before starting the node sorts the set $stored$ after the ticket index, yielding the ordered set $sorted$.

The node now proves one-by-one to the smart contract that the tickets in $sorted$ are indeed a win. If successful, the smart contract credits the stated incentive to the account of the node. The details are covered in the section on \lcnameref{sec:incentives:channels} and out of scope for this section.

\paragraph{Validation of submitted tickets}
\label{sec:tickets:redemption:submitted}

The duty of the smart contract is to verify the validity of the submitted ticket. This is done in multiple and failing one step results in a rejection of the ticket.

In contrast to ticket recipients, the smart contract considers a ticket only valid if the redeemer is able to provide a $response$ that solves $ticket.challenge$. Note that the smart contract thereby acts as a trusted third party that forces the node reveal additional values despite the signature of the ticket is valid.

\subparagraph{Challenge} Solving a challenge $C$ means finding a value $r$ such that $r \cdot G =C$. Hence, in order to check this equation, the smart contract needs to compute a scalar multiplication of an elliptic curve point, which is as of writing of the paper not directly available within Ethereum.

Instead, Ethereun allows to efficiently implement a function $mul'$:

$$ mul': x \in \mathbb{F} \mapsto addr (x \cdot G)$$

where $addr$ maps uncompressed elliptic curve points to Ethereum addresses by hashing and slicing the hash of the given public key. Hence, the smart contract compares the computed Ethereum address against the one stated in the ticket.

\subparagraph{Issuer signature}

After computing $C' = mul'(response)$ the smart contract is able to recompute the hash of the ticket, which is given as:
\begin{multline*}
    ticketHash = keccak256 (ticket.recipient \ || \ C' \ || \ ticket.ticketEpoch \ ||  \\
    ticket.amount \ || \ ticket.invWinProb \ || \\
    ticket.index \ || \ ticket.channelEpoch)
\end{multline*}

and is thus able by using the provided signature to recover the public key of the ticket issuer. Having both Ethereum addresses, the one of the issuer and the one of the recipient allows the smart contract to compute that identifier of the utilized payment channel, yielding $channelId$.

\subparagraph{Payment channel validation}

The goal of this step is to check if there exists such a payment channel within the storage of the smart contract and if so, if it is able to cover for the embedded amount.

As the previous steps were computed without any feedback to the computed values, either signature and $response$ to the challenge were correct and there exists a record for a payment channel or any of the conditions is not met. Due to the usage of a collision-resistant hash function, it is assumed to be infeasible for an attacker to find a second pre-image that maps the ticket hash to a specific $channelId$.

If the computed value leads to an appropriate channel instance, the smart contract checks that $channel.amount \le ticket.amount$ and rejects the ticket otherwise.

\subparagraph{Replay protections}

A ticket can be valid due to valid signature and correct $response$, but as it controls an asset transfer and thereby initiates on-chain state changes, it should be valid exactly \textit{once}.

Each ticket is given an ongoing serial number $i$ and each ticket redemption sets the on-chain value $channel.index$ to $ticket.index$ if $ticket.index > channel.index$. Otherwise, the ticket is rejected.

Analogously, each reincarnation of the payment channel, i.e. a sequence of $open$, $close$, increases the channel epoch counter. To turn tickets issued for previous incarnations of the payment channe invalid, the smart contract rejects all tickets with $ticket.channelEpoch \neq channel.epoch$

Last but not least, each renewal of the on-chain commitment increases the ticket epoch counter. And to prevent from nodes resetting the ticket epoch counter to values that they find more beneficial, e.g. in order to tweak the ticket's winning probability and turn previously losing tickets into winning ones. Hence, the smart contract rejects all tickets for which $ticket.ticketEpoch \neq channel.ticketEpoch$.

\subparagraph{Commitment}



\subparagraph{Ticket luck}

% \subparagraph{Payment channel validation}
% \begin{itemize}
%       \item
%             \textbf{Stored ticket} Once the node receives an acknowledgement, it checks whether it is storing an unacknowledged ticket corresponding to the received acknowledgement. If it does not, the node should drop the acknowledgement.

%             The node then computes the response to the challenge (also referred to as the \textit{proof of relay secret}) given in the ticket as $$r_i=(s_i^{(0)}+s_{i+1}^{(1)})*G$$
%       \item
%             \textbf{Sufficient challenge information} The node checks whether the information gained from the packet transformation is sufficient to fulfil the challenge sent along with the ticket, $$r_i*G=T_{c_i}$$

%             The node then replies with an acknowledgement which includes a response to the challenge. If this is not the case, the node should drop the packet.
% \end{itemize}

% Both the node and the smart contract then perform the following checks:

% \begin{itemize}
%       \item
%             \textbf{Channel existence} The node checks that the appropriate chan nel \textbf{exists} and is \textbf{open} or \textbf{pending to close}. If these checks do not pass, the node should drop the packet and the smart contract check will revert. To prevent metadata leakage, the check happens locally rather than on-chain using the blockchain indexer. If the node has no record of the channel or considers the channel to be in a state different from \textbf{open} or \textbf{pending to close}, the ticket is dropped and receipt of the accompanying packet is rejected.
%       \item
%             \textbf{Commitment value check} Additionally, the node and the smart contract retrieve the next commitment value, $comm_{i-1}$. They then check that this value is not empty and that the commitment is the opening of the next commitment as follows: $$ comm_{i-1} \neq 0 \; and \; comm_{i}=h(comm_{i-1})$$
%       \item
%             \textbf{Commitment verification} The node then verifies that $r_i$ and $comm_{i-1}$ lead to a winning ticket. This is the case if $$h(t_h, comm_{i-1}, r_i) <P_w$$ where $t_h=h(t)$ is the ticket hash. The values are first ABI encoded, then hashed using keccak256 and last but not least converted to uint256.

%             If the check is not valid, the node should drop the packet.
%             The final recipient of the packet does not receive a ticket because packet receipt is not incentivized by the HOPR protocol.
%       \item
%             \textbf{Issuer identity} The ticket signer must be same as the ticket issuer. Both node and smart contract verify whether the public key associated to the private key used to sign $$T= (t, Sig_I(t))$$ is the issuer's public key. The packet is dropped if this test fails and ticket redemption reverts.
%       \item
%             \textbf{Prior redemption} The ticket must not have been already redeemed and the ticket index must be strictly greater than the current value in the smart contract (replay protection).
%             $$I_c <I$$ where $I_c$ is the current value in the smart contract and $I$ is the ticket index.
%       \item
%             \textbf{Valid ticket amount} The amount of ticket must be greater than 0: $$\sigma>0$$ where $\sigma$ is the ticket amount.
%       \item
%             \textbf{Liquidity check} The channel must have enough funds to cover the value transfer for the ticket: $$ C_b>\sigma$$ where $C_b$ is the channel balance.
% \end{itemize}

% Finally, the smart contract also performs an epoch check:
% \begin{itemize}
%       \item
%             \textbf{Epoch check} The ticket epoch, $\alpha$, and channel epoch, $\zeta$, must be equal to the current values in the smart contract $$\alpha=\alpha_c \;\; and \;\; \zeta=\zeta_c$$ where $\alpha_c$ and $\zeta_c$ represent the current values in the smart contract.
% \end{itemize}
