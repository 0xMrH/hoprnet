\subsection{Ticket Redemption}
\label{sec:tickets:redemption}

In order to unlock a ticket, the recipient node stores the ticket within its database until it receives an acknowledgement containing $s_{i+1}$ from the next downstream node. HOPR uses acknowledgements to prove the correct transformation of mixnet packets as well as their delivery to the next downstream node.

The challenge can be computed from the acknowledgement as $T_{c_i}=Ack_i*G$. The node checks the following in order to redeem its ticket:
\begin{itemize}
    \item
          \textbf{Stored ticket} Once the node receives an acknowledgement, it checks whether it is storing an unacknowledged ticket corresponding to the received acknowledgement. If it does not, the node should drop the acknowledgement.

          The node then computes the response to the challenge (also referred to as the \textit{proof of relay secret}) given in the ticket as $$r_i=(s_i^{(0)}+s_{i+1}^{(1)})*G$$
    \item
          \textbf{Sufficient challenge information} The node checks whether the information gained from the packet transformation is sufficient to fulfil the challenge sent along with the ticket, $$r_i*G=T_{c_i}$$

          The node then replies with an acknowledgement which includes a response to the challenge. If this is not the case, the node should drop the packet.
\end{itemize}

Both the node and the smart contract then perform the following checks:

\begin{itemize}
    \item
          \textbf{Channel existence} The node checks that the appropriate chan nel \textbf{exists} and is \textbf{open} or \textbf{pending to close}. If these checks do not pass, the node should drop the packet and the smart contract check will revert. To prevent metadata leakage, the check happens locally rather than on-chain using the blockchain indexer. If the node has no record of the channel or considers the channel to be in a state different from \textbf{open} or \textbf{pending to close}, the ticket is dropped and receipt of the accompanying packet is rejected.
    \item
          \textbf{Commitment value check} Additionally, the node and the smart contract retrieve the next commitment value, $comm_{i-1}$. They then check that this value is not empty and that the commitment is the opening of the next commitment as follows: $$ comm_{i-1} \neq 0 \; and \; comm_{i}=h(comm_{i-1})$$
    \item
          \textbf{Commitment verification} The node then verifies that $r_i$ and $comm_{i-1}$ lead to a winning ticket. This is the case if $$h(t_h, comm_{i-1}, r_i) <P_w$$ where $t_h=h(t)$ is the ticket hash. The values are first ABI encoded, then hashed using keccak256 and last but not least converted to uint256.

          If the check is not valid, the node should drop the packet.
          The final recipient of the packet does not receive a ticket because packet receipt is not incentivized by the HOPR protocol.
    \item
          \textbf{Issuer identity} The ticket signer must be same as the ticket issuer. Both node and smart contract verify whether the public key associated to the private key used to sign $$T= (t, Sig_I(t))$$ is the issuer's public key. The packet is dropped if this test fails and ticket redemption reverts.
    \item
          \textbf{Prior redemption} The ticket must not have been already redeemed and the ticket index must be strictly greater than the current value in the smart contract (replay protection).
          $$I_c <I$$ where $I_c$ is the current value in the smart contract and $I$ is the ticket index.
    \item
          \textbf{Valid ticket amount} The amount of ticket must be greater than 0: $$\sigma>0$$ where $\sigma$ is the ticket amount.
    \item
          \textbf{Liquidity check} The channel must have enough funds to cover the value transfer for the ticket: $$ C_b>\sigma$$ where $C_b$ is the channel balance.
\end{itemize}

Finally, the smart contract also performs an epoch check:
\begin{itemize}
    \item
          \textbf{Epoch check} The ticket epoch, $\alpha$, and channel epoch, $\zeta$, must be equal to the current values in the smart contract $$\alpha=\alpha_c \;\; and \;\; \zeta=\zeta_c$$ where $\alpha_c$ and $\zeta_c$ represent the current values in the smart contract.
\end{itemize}
